#include <iostream>

#undef UNICODE

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <regex>
#include "Http\HttpLib.h"
#include "Http\UtilLib.h"

// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")
// #pragma comment (lib, "Mswsock.lib")

#define PORT "8000"
#define URL "70.61.16.8"

DWORD WINAPI runServer(LPVOID lpParameter);
char* GetIP();

// vector<string> keys = vector<string>();

using namespace std;
vector<HANDLE> threads = vector<HANDLE>();
vector<string> keys = vector<string>();
vector<string> values = vector<string>();

int main(int argc, char* argv[])
{
  char* port = "8000";
	DWORD myThreadID;
	HANDLE threadHandle = CreateThread(0, 2048, runServer, port, 0, &myThreadID);
  // CreateThread returns null on failure
  if(threadHandle != NULL){
    threads.push_back(threadHandle);
  }

  system("pause");

  // clean up and close all threads
  while(threads.size() > 0){
    CloseHandle(threads.back());
    threads.pop_back();
  }

	return 0;
}

DWORD WINAPI runServer(LPVOID lpParameter){
  char* port = ((char*)lpParameter);

  const char* mutexName = "test";
  HANDLE mHandle = CreateMutex(NULL, true, mutexName);
  if(GetLastError() == ERROR_ALREADY_EXISTS){
    printf("Mutex already locked\n");
    return 1;
  }

  keys.push_back("ip_address");
  values.push_back(GetIP());
  keys.push_back("port");
  values.push_back(port);

  char* args;
  // getArgsToString(keys, values, getSize(keys), { "mac_address", "bot_id", "ip_address", "port" }, 4, "POST", &args);
  // char* response = httpPostRequest(URL, "/database/api/server/status/", 50000, args);
  // printf("Res: %s\n", response);
  // delete args;
  // delete response;
  removeElement(keys, values, "ip_address");
  removeElement(keys, values, "port");

  WSADATA wsaData;
  int iResult;

  SOCKET ListenSocket = INVALID_SOCKET;
  SOCKET ClientSocket = INVALID_SOCKET;

  struct addrinfo *result = NULL;
  struct addrinfo hints;

  int iSendResult;
  char recvbuf[512];
  int recvbuflen = 512;

  // Initialize Winsock
  iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
  if (iResult != 0) {
    printf("WSAStartup failed with error: %d\n", iResult);
    return 1;
  }

  ZeroMemory(&hints, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = IPPROTO_TCP;
  hints.ai_flags = AI_PASSIVE;

  // Resolve the server address and port
  iResult = getaddrinfo(NULL, port, &hints, &result);
  if ( iResult != 0 ) {
    printf("getaddrinfo failed with error: %d\n", iResult);
    WSACleanup();
    return 1;
  }

  // Create a SOCKET for connecting to server
  ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
  if (ListenSocket == INVALID_SOCKET) {
    printf("socket failed with error: %ld\n", WSAGetLastError());
    freeaddrinfo(result);
    WSACleanup();
    return 1;
  }

  // Setup the TCP listening socket
  iResult = bind( ListenSocket, result->ai_addr, (int)result->ai_addrlen);
  if (iResult == SOCKET_ERROR) {
    printf("bind failed with error: %d\n", WSAGetLastError());
    freeaddrinfo(result);
    closesocket(ListenSocket);
    WSACleanup();
    return 1;
  }

  freeaddrinfo(result);

  iResult = listen(ListenSocket, SOMAXCONN);
  if (iResult == SOCKET_ERROR) {
    printf("listen failed with error: %d\n", WSAGetLastError());
    closesocket(ListenSocket);
    WSACleanup();
    return 1;
  }

  bool run = true;
  // enter endless loop unless the kill command is sent
  while(run){
    // Accept a client socket
    ClientSocket = accept(ListenSocket, NULL, NULL);
    if (ClientSocket == INVALID_SOCKET) {
      printf("accept failed with error: %d\n", WSAGetLastError());
      closesocket(ListenSocket);
      WSACleanup();
      return 1;
    }
    // clear the buffer
    memset(recvbuf, 0, 512);

    // Receive until the peer shuts down the connection
    do {
      iResult = recv(ClientSocket, recvbuf, recvbuflen, 0);
      if (iResult > 0) {
        printf("Received: %s\n", recvbuf);

        if(strcmp(recvbuf, "kill") == 0){
          // set flag to end listen loop
          run = false;
          // send something back so python can close the connection
          iSendResult = send( ClientSocket, "\0", iResult, 0 );
          // break to jump out of the reading buffer loop
          break;
        }
        // if the data received matches the pattern for actions
        else if(regex_match(recvbuf, regex("([a-z_0-9]+:\\[(((, )?[a-z_0-9]+)?)+\\](, )?)+"))){
          printf("its matches the pattern\n");
          string s = "action_bot2:[thing1, thing3, thing3], acon_bot2:[thifg2, thfing3, tieg3]";
          regex words_regex("[a-z_0-9]+:\\[(((, )?[a-z_0-9]+)?)+\\]");
          auto words_begin = sregex_iterator(s.begin(), s.end(), words_regex);
          auto words_end = sregex_iterator();

          cout << "Found "
          << distance(words_begin, words_end)
          << " words:\n";

          for (sregex_iterator i = words_begin; i != words_end; ++i) {
            smatch match = *i;
            string match_str = match.str();
            cout << match_str << '\n';
          }
        }

        // Echo the buffer back to the sender
        iSendResult = send( ClientSocket, recvbuf, iResult, 0 );
        if (iSendResult == SOCKET_ERROR) {
          printf("send failed with error: %d\n", WSAGetLastError());
          closesocket(ClientSocket);
          WSACleanup();
          return 1;
        }
        printf("Sent back: %s\n\n", recvbuf);
      }
      else if (iResult == 0){
        // do nothing, 0 will break out of the reading loop
      }else  {
        printf("recv failed with error: %d\n", WSAGetLastError());
        closesocket(ClientSocket);
        WSACleanup();
        return 1;
      }
    } while (iResult > 0);
  }// end while

  // No longer need server socket
  closesocket(ListenSocket);

  // shutdown the connection since we're done
  iResult = shutdown(ClientSocket, SD_SEND);
  if (iResult == SOCKET_ERROR) {
    printf("shutdown failed with error: %d\n", WSAGetLastError());
    closesocket(ClientSocket);
    WSACleanup();
    return 1;
  }

  // cleanup
  closesocket(ClientSocket);
  WSACleanup();
  ReleaseMutex(mHandle);
}

char* GetIP()
{
	WSAData wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	HOSTENT* Host;
	char hostname[128] = { 0 };
	char* IPv4 = new char[128];
	gethostname(hostname, 128);
	Host = gethostbyname(hostname);
	IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
	WSACleanup();
	return IPv4;
}
