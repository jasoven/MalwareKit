import os
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'malware_toolkit_project.settings')

import django
django.setup()

from malware_toolkit.models import Feature, Function, Body, \
    Global_Variables, Import, Header, Definition
from django.core.exceptions import ObjectDoesNotExist

def add_new_feature(feat):
    print(feat['name'])
    print(feat['body'])
    f = Feature.objects.get_or_create(name=feat['name'])[0]
    f.priority = feat['priority']
    f.feature_type = feat['type']
    add_update_table(Body, "feature", f, feat['body'])
    # add_function(feat, feat.function)
    f.save()

# TODO - add exception handling
def add_new_function(func):
    print(func['name'])
    print(func['globals'])
    print(func['import'])
    print(func['declaration'])
    print(func['definition'])
    f = Function.objects.get_or_create(name=func['name'])[0]
    add_update_table(Global_Variables, "function", f, func['globals'])
    add_update_table(Import, "function", f, func['import'])
    add_update_table(Header, "function", f, func['declaration'])
    add_update_table(Definition, "function", f, func['definition'])

# func - string
# deletes a function by name (string)
def delete_function(func):
    f = Function.objects.get_or_create(name=func)[0]
    f.delete()

# table - models.table name
# rName - name of the record to be deleted (string)
# deletes a feature by name (string)
def delete_record_by_name(table, rName):
    r = table.objects.get_or_create(name=rName)[0]
    r.delete()

def add_update_table(table, fKeyType, fKey, g_lines):
    line_counter = 0
    empty = True
    g = None
    if fKeyType == "function":
        g = table.objects.all().filter(function=fKey)
    elif fKeyType == "feature":
        g = table.objects.all().filter(feature=fKey)
    # if we found records, we need to remove excess rows
    if g:
        # we will need to remember if there were records in the table
        empty = False
        end = len(g)
        while end > len(g_lines):
            end -= 1
            g[end].delete()

    for l in g_lines:
        # only if we found recods in the table with len(g) succeed
        if not empty:
            if line_counter < len(g):
                g[line_counter].text = l
                g[line_counter].save()
                line_counter += 1
                continue

        if fKeyType == "function":
            table.objects.get_or_create(function=fKey, \
                text=l, line_number=line_counter)[0].save()
        elif fKeyType == "feature":
            table.objects.get_or_create(feature=fKey, \
                text=l, line_number=line_counter)[0].save()
        line_counter += 1

# func_str - String name of the function
# returns a QuerySet of models.'Table' object tied to the given function
# returns None if nothing was found or error encountered
def get_records_from_table(table, func_str):
    records = None
    try:
        # get the function id (foreign key)
        # based on the function name passed in
        func_id = Function.objects.get(name=func_str)
        # use function_id to query for the import objects
        records = table.objects.all().filter(function=func_id)
    except ObjectDoesNotExist as e:
        print("function '" + func_str + "' does not exist")
    return records
