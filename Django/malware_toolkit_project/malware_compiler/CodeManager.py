import os
import subprocess
import datetime
import re

class CodeManager:
    'Class for managing source code'
    souceCodeObj = None
    buildOutputFile = 'build.log'

    def __init__(self, sourceCode):
      self.sourceCodeObj = sourceCode

    # adds header, defition and function call to the source code object
    # feature_obj is an object of the class MalwareFeature
    def add_malware_feature(self, feature_obj):
        for d in feature_obj.get_func_declarations():
            self.sourceCodeObj.add_func_declaration(d)
        for g in feature_obj.get_global_variables():
            self.sourceCodeObj.add_global_variable(g)
        for d in feature_obj.get_func_definitions():
            self.sourceCodeObj.add_func_definition(d)
        for c in feature_obj.get_func_call():
            self.sourceCodeObj.add_line_to_main(c)

    # prints build results to a file specified in the global scope
    # output_filename - the file to open and write the output to
    # buid_cmd - the commmand that was executed
    # build_output - the results of the command
    def log_build_results(self, output_filename, build_cmd, build_err, build_out):
        output_log = open(output_filename, 'a')
        output_log.write('--------------------------------------------------\n')
        date = datetime.datetime.now().date()
        time = datetime.datetime.now().time()
        output_log.write('Time: ' + str(date) + ' ' + str(time) + '\n')
        output_log.write("Build Command: " + str(build_cmd) + '\n')
        output_log.write(str(build_err))
        output_log.write('Build Error:\n' + str(build_out) + '\n')
        output_log.write('--------------------------------------------------\n')
        output_log.close()

    # calls g++ to build the source file into an executable
    # exe_file_name - the name of the executable to be compiled
    # source_file_name - the name of the source code file
    def build_executable(self, exe_file_name, source_file_name):
        # 0: success, -1: failure
        buildRes = -1
        # have the sourceCodeObj export the code to a file
        if os.path.isfile(source_file_name):
            os.remove(source_file_name)
        self.sourceCodeObj.export_code(source_file_name)
        # check if the sourceCode File exist first
        if os.path.isfile(source_file_name):
            buildCmd = 'cl /Fe' + exe_file_name + ' ' + source_file_name
            # buildCmd = 'g++ -o ' + exe_file_name + ' ' + source_file_name
            proc = subprocess.Popen(buildCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (stdout, stderr) = proc.communicate()

            # since 'cl' always outputs some copyright text to stderr, and actual
            # errors go to stdout, we cannot use that as a method to determine
            # compilation erros like we could with g++ so regex is the alternative
            if re.search('/out:' + exe_file_name, stdout) is None:
                print("Build Failed")
                self.log_build_results(self.buildOutputFile, buildCmd, stderr, stdout)
                buildRes = -1
            else:
                print("Build Successful")
                buildRes = 0
            # clear source code state, whether build was successful or not
            # so it is ready for the next build
            self.sourceCodeObj.clearState()
        else:
            print("Source code file does not exist")
            buildRes = -1
        return buildRes
