from django.shortcuts import render
from django.http import HttpResponse
from django.utils import datastructures
from malware_toolkit.models import Feature, Function, \
    Global_Variables, Import, Header, Definition, Body, \
    Feature_Function, Feature_Type, Toolkit_Option
from malware_toolkit.forms import FeatureForm
import json
import DAO
from os import getcwd
from os import pardir
import sys
malware_compiler_path = getcwd() + '\malware_compiler'
sys.path.insert(0, malware_compiler_path)
from build import main
import re

# Create your views here.
def index(request):

    # Construct a dictionary to pass to the template engine as its context.
    # Note the key boldmessage is the same as {{ boldmessage }} in the template!
    context_dict = {'boldmessage': "I am bold font from the context",
                    'message1': "this is a message"}

    # Return a rendered response to send to the client.
    # We make use of the shortcut function to make our lives easier.
    # Note that the first parameter is the template we wish to use.

    return render(request, 'malware_toolkit/index.html', context_dict)

def features(request):
    features = Feature.objects.all()
    functions = Function.objects.all()
    funcArray = []
    for f in functions:
        func = {}
        func['name'] = f.name
        func['header'] = DAO.get_records_from_table(Header, 'function', f.name)[0].text
        funcArray.append(func)
    feature_types = Feature_Type.objects.all()

    context_dict = {'features': features,
                    'functions': funcArray,
                    'feature_types': feature_types,
                    'title': "Malware Features",
                    }

    return render(request, 'malware_toolkit/features.html', context_dict)

def functions(request):
    functions = Function.objects.all()
    context_dict = {'functions': functions,
                    'title': "Malware Functions",
                    }

    return render(request, 'malware_toolkit/functions.html', context_dict)

def toolkit(request):
    features = {}
    types = Feature_Type.objects.all()
    for t in types:
        feats = Feature.objects.all().filter(feature_type=t)
        for f in feats:
            f.options = Toolkit_Option.objects.all().filter(feature=f)
        features[t.name] = feats

    context_dict = {'title': "TaaSera Malware Toolkit",
                    'type_1': "Execution Conditions",
                    'type_2': "Executable Features",
                    'type_3': "Action Sequence",
                    'features_1': features["Execution Condition"],
                    'features_2': features["Executable Feature"],
                    'features_3': features["Action Sequence"],
                    'features': features,
                    }

    return render(request, 'malware_toolkit/toolkit.html', context_dict)

def add_function(request):
    if request.method == "POST":
        postData = re.split(r'b\'\{\"(.+|\[+|\]+)\"\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"]}"
        func = json.loads(jsonData)
        funcObj = {}
        funcObj['name'] = func['name']
        funcObj['globals'] = func['global']
        funcObj['import'] = func['import']
        funcObj['declaration'] = func['declaration']
        funcObj['definition'] = func['definition']

        DAO.add_new_function(funcObj)

    return HttpResponse(200)

def add_feature(request):
    if request.method == "POST":
        print(request.body)
        postData = re.split(r'{\"(.+|\[+|\]+)\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "]}"
        print(jsonData)
        feat = json.loads(jsonData)
        type_name = feat['type']
        feat_type = Feature_Type.objects.get_or_create(name=type_name)[0]

        featObj = {}
        featObj['name'] = feat['name']
        featObj['body'] = feat['body']
        featObj['priority'] = feat['priority']
        featObj['functions'] = feat['functions']
        featObj['type'] = feat_type
        featObj['prompt'] = feat['prompt']
        featObj['options'] = feat['options']

        DAO.add_new_feature(featObj)

    return HttpResponse(200)

def get_imports(request):
    try:
        func = request.GET['name']
    except datastructures.MultiValueDictKeyError as e:
        return HttpResponse(400)

    imports = DAO.get_function_imports(func)
    parsed_i = []
    if(imports != None):
        for i in imports:
            parsed_i.append(i.text)
    return HttpResponse(json.dumps(parsed_i))

def get_function(request):
    if request.method == "DELETE":
        postData = re.split(r'b\'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        func = json.loads(jsonData)
        DAO.delete_function(func['name'])
        return HttpResponse(200)
    else:
        try:
            func = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        global_vars = DAO.get_records_from_table(Global_Variables, 'function', func)
        imports = DAO.get_records_from_table(Import, 'function', func)
        header = DAO.get_records_from_table(Header, 'function', func)
        definition = DAO.get_records_from_table(Definition, 'function', func)
        parsed_g = make_array(global_vars)
        parsed_i = make_array(imports)
        parsed_h = make_array(header)
        parsed_d = make_array(definition)

        funcObj = {}
        funcObj['globals'] = parsed_g
        funcObj['imports'] = parsed_i
        funcObj['header'] = parsed_h
        funcObj['definition'] = parsed_d

        return HttpResponse(json.dumps(funcObj))

def get_feature(request):
    if request.method == "DELETE":
        postData = re.split(r'b\'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        feat = json.loads(jsonData)
        DAO.delete_record_by_name(Feature, feat['name'])
        return HttpResponse(200)
    elif request.method == "GET":
        try:
            feat = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        print("feat is " + feat)
        # try to find the feature, if it doesnt exist return 400
        try:
            feat = Feature.objects.get(name=feat)
        except Feature.DoesNotExist:
            return HttpResponse(400)
        body = DAO.get_records_from_table(Body, 'feature', feat)
        parsed_b = make_array(body)
        try:
            feat_type = Feature_Type.objects.get(feature=feat).name
        except Feature_Type.DoesNotExist:
            feat_type = ""
        options = DAO.get_records_from_table(Toolkit_Option, 'feature', feat)
        parsed_opts = make_array(options)
        funcs = DAO.get_records_from_table(Feature_Function, 'feature', feat)
        func_names = []
        for f in funcs:
            func_names.append(f.function.name)

        featObj = {}
        featObj['priority'] = feat.priority
        featObj['type'] = feat_type
        featObj['body'] = parsed_b
        featObj['functions'] = func_names
        featObj['prompt'] = feat.toolkit_prompt
        featObj['options'] = parsed_opts

        return HttpResponse(json.dumps(featObj))

def build(request):
    print("building")
    main()
    return HttpResponse(200)

def make_array(qSet):
    array = []
    if(qSet != None):
        for s in qSet:
            array.append(s.text)
    return array
