from django.shortcuts import render
from django.http import HttpResponse
from django.core.servers.basehttp import FileWrapper
from django.utils import datastructures
from django.views.decorators.csrf import csrf_exempt
from django.core.exceptions import ObjectDoesNotExist
from malware_toolkit.models import Feature, Function, \
    Global_Variables, Import, Header, Definition, Body, \
    Feature_Function, Feature_Type, Toolkit_Option
import json
import DAO
from os import getcwd
from os import pardir
import sys
malware_compiler_path = getcwd() + '/malware_compiler'
print(malware_compiler_path)
sys.path.insert(0, malware_compiler_path)
from build import main
import re
import httplib, urllib

# used to authenticate POSTs on the BotMaster
BOTMASTER_PASSPHRASE = 'A79BH4G9'

def index(request):

    # Construct a dictionary to pass to the template engine as its context.
    # Note the key boldmessage is the same as {{ boldmessage }} in the template!
    context_dict = {'boldmessage': "I am bold font from the context",
                    'message1': "this is a message"}

    # Return a rendered response to send to the client.
    # We make use of the shortcut function to make our lives easier.
    # Note that the first parameter is the template we wish to use.

    return render(request, 'malware_toolkit/index.html', context_dict)

def features(request):
    features = Feature.objects.all()
    functions = Function.objects.all()
    funcArray = []
    for f in functions:
        func = {}
        func['name'] = f.name
        h = DAO.get_records_from_table(Header, 'function', f.name)
        # if the function is just used for a #define, the set will be empty
        if len(h) > 0:
            func['header'] = h[0].text
        else:
            func['header'] = ''
        funcArray.append(func)
    feature_types = Feature_Type.objects.all()

    context_dict = {'features': features,
                    'functions': funcArray,
                    'feature_types': feature_types,
                    'title': "Malware Features",
                    }

    return render(request, 'malware_toolkit/features.html', context_dict)

def functions(request):
    functions = Function.objects.all()
    context_dict = {'functions': functions,
                    'title': "Malware Functions",
                    }

    return render(request, 'malware_toolkit/functions.html', context_dict)

def toolkit(request):
    features = {}
    types = Feature_Type.objects.all()
    for t in types:
        feats = Feature.objects.all().filter(feature_type=t)
        for f in feats:
            f.options = Toolkit_Option.objects.all().filter(feature=f)
        features[t.name] = feats

    context_dict = {'title': "TaaSera Malware Toolkit",
                    'type_1': "Execution Conditions",
                    'type_2': "Executable Features",
                    'type_3': "Action Sequence",
                    'features_1': features["Execution Condition"],
                    'features_2': features["Executable Feature"],
                    'features_3': features["Action Sequence"],
                    'features': features,
                    }

    return render(request, 'malware_toolkit/toolkit.html', context_dict)

@csrf_exempt
def test(request):
    if request.method == "POST":
        postData = request.body
        print(postData)
        return HttpResponse(201)
    else:
        print("got a GET")
        getData = request.GET['city']
        print(getData)
        return HttpResponse(202)

def add_function(request):
    if request.method == "POST":
        print(str(request.body))
        postData = re.split(r'\{\"(.+|\[+|\]+)\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "]}"
        func = json.loads(jsonData)
        funcObj = {}
        funcObj['name'] = func['name']
        funcObj['globals'] = func['global']
        funcObj['import'] = func['import']
        funcObj['declaration'] = func['declaration']
        funcObj['definition'] = func['definition']

        DAO.add_new_function(funcObj)

    return HttpResponse(200)

def add_feature(request):
    if request.method == "POST":
        print(request.body)
        postData = re.split(r'{\"(.+|\[+|\]+)\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "]}"
        print(jsonData)
        feat = json.loads(jsonData)
        type_name = feat['type']
        feat_type = Feature_Type.objects.get_or_create(name=type_name)[0]

        featObj = {}
        featObj['name'] = feat['name']
        featObj['body'] = feat['body']
        featObj['priority'] = feat['priority']
        featObj['functions'] = feat['functions']
        featObj['type'] = feat_type
        featObj['prompt'] = feat['prompt']
        featObj['options'] = feat['options']

        DAO.add_new_feature(featObj)

        # tell the BotMaster that a new action sequence is available
        if(type_name == 'Action Sequence'):
            sendAction(featObj['name'])

    return HttpResponse(200)

def get_imports(request):
    try:
        func = request.GET['name']
    except datastructures.MultiValueDictKeyError as e:
        return HttpResponse(400)

    imports = DAO.get_function_imports(func)
    parsed_i = []
    if(imports != None):
        for i in imports:
            parsed_i.append(i.text)
    return HttpResponse(json.dumps(parsed_i))

def get_function(request):
    if request.method == "DELETE":
        print(str(request.body))
        postData = re.split(r'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        func = json.loads(jsonData)
        DAO.delete_function(func['name'])
        return HttpResponse(200)
    else:
        try:
            func = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        funcObj = DAO.get_python_function_obj(func)
        if funcObj == None:
            return HttpResponse(400)

        return HttpResponse(json.dumps(funcObj))

def get_feature(request):
    if request.method == "DELETE":
        HttpResponse(200)
        postData = re.split(r'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        feat = json.loads(jsonData)
        DAO.delete_record_by_name(Feature, feat['name'])
        return HttpResponse(200)
    elif request.method == "GET":
        try:
            feat = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        print("feat is " + feat)
        # try to find the feature, if it doesnt exist return 400
        feat = DAO.get_python_feature_obj(feat)
        if feat == None:
            return HttpResponse(400)
        return HttpResponse(json.dumps(feat))

def build(request):
    if request.method == "POST":
        postData = re.split(r'\{\"(.+|\[+|\]+)\}', str(request.body))[1]
        postData = '{"' + postData + '}'
        jsonData = json.loads(postData)
        featList = []
        # actionList will be used again when we send the list to the
        # BotMaster to record this Bots capabilites
        actionList = None
        if 'Execution Conditions' in jsonData:
            exeFeats = jsonData['Execution Conditions']
            for f in exeFeats:
                featList.append(f)
        if 'Executable Features' in jsonData:
            exeFeats = jsonData['Executable Features']
            for f in exeFeats:
                featList.append(f)
        if 'Action Sequence' in jsonData:
            actionList = jsonData['Action Sequence']
            for a in actionList:
                featList.append(a)
        # print(featList)

    # HARDCODED TO TRUE while developing the post request, since the actions sequences dont compile yet
    exePath, botID = main(featList)
    # results = "/somewhere"
    # results = 'test.exe' # a successful build

    if exePath != -1:
        # if it failed the result will be -1 otherwise it'll be the path to the exe
        exePath = re.sub(r'\\', '/', exePath)
        filename = 'http://localhost:50000/' + exePath
        # send POST to the BotMaster with the bot's ID and a list of its available add_func_definitions
        sendBotActionList(actionList, botID)
        return HttpResponse('200 ' + filename)
    else:
        return HttpResponse(503)

# sends a new action to the BotMaster, when new feature are added to the toolkit
def sendAction(action):
    data = {'passphrase': BOTMASTER_PASSPHRASE, \
                               'action': action}
    jsonData = json.dumps(data)
    conn = httplib.HTTPConnection("70.61.16.8:50000")
    conn.request("POST", "/database/api/add_action/", jsonData)
    res = conn.getresponse()
    # if the response is a success
    if res.read() == '200':
        print("New Action successfully added to BotMaster")
    else:
        print("Failed to send new action to BotMaster")
    conn.close()

# sends a list of actions to the BotMaster that this bot is capable of performing
def sendBotActionList(actions, botID):
    # TODO - generate random bot id
    data = {'passphrase': BOTMASTER_PASSPHRASE, \
                               'bot': botID, \
                               'actions': actions}
    jsonData = json.dumps(data)
    conn = httplib.HTTPConnection("70.61.16.8:50000")
    conn.request("POST", "/database/api/add_bot/", jsonData)
    res = conn.getresponse()
    # if the response is a success
    if res.read() == '200':
        print("List of bot actions successfully sent to BotMaster")
    else:
        print("Failed to send list of bot actions to BotMaster")
    conn.close()

def make_array(qSet):
    array = []
    if(qSet != None):
        for s in qSet:
            array.append(s.text)
    return array
