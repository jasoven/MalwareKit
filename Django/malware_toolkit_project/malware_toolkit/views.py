from django.shortcuts import render
from django.http import HttpResponse
from django.core.servers.basehttp import FileWrapper
from django.utils import datastructures
# from django.views.decorators.csrf import csrf_exempt
from malware_toolkit.models import Feature, Function, \
    Global_Variables, Import, Header, Definition, Body, \
    Feature_Function, Feature_Type, Toolkit_Option
from malware_toolkit.forms import FeatureForm
import json
import DAO
from os import getcwd
from os import pardir
import sys
malware_compiler_path = getcwd() + '/malware_compiler'
print(malware_compiler_path)
sys.path.insert(0, malware_compiler_path)
from build import main
import re

def index(request):

    # Construct a dictionary to pass to the template engine as its context.
    # Note the key boldmessage is the same as {{ boldmessage }} in the template!
    context_dict = {'boldmessage': "I am bold font from the context",
                    'message1': "this is a message"}

    # Return a rendered response to send to the client.
    # We make use of the shortcut function to make our lives easier.
    # Note that the first parameter is the template we wish to use.

    return render(request, 'malware_toolkit/index.html', context_dict)

def features(request):
    features = Feature.objects.all()
    functions = Function.objects.all()
    funcArray = []
    for f in functions:
        func = {}
        func['name'] = f.name
        func['header'] = DAO.get_records_from_table(Header, 'function', f.name)[0].text
        funcArray.append(func)
    feature_types = Feature_Type.objects.all()

    context_dict = {'features': features,
                    'functions': funcArray,
                    'feature_types': feature_types,
                    'title': "Malware Features",
                    }

    return render(request, 'malware_toolkit/features.html', context_dict)

def functions(request):
    functions = Function.objects.all()
    context_dict = {'functions': functions,
                    'title': "Malware Functions",
                    }

    return render(request, 'malware_toolkit/functions.html', context_dict)

def toolkit(request):
    features = {}
    types = Feature_Type.objects.all()
    for t in types:
        feats = Feature.objects.all().filter(feature_type=t)
        for f in feats:
            f.options = Toolkit_Option.objects.all().filter(feature=f)
        features[t.name] = feats

    context_dict = {'title': "TaaSera Malware Toolkit",
                    'type_1': "Execution Conditions",
                    'type_2': "Executable Features",
                    'type_3': "Action Sequence",
                    'features_1': features["Execution Condition"],
                    'features_2': features["Executable Feature"],
                    'features_3': features["Action Sequence"],
                    'features': features,
                    }

    return render(request, 'malware_toolkit/toolkit.html', context_dict)

def add_function(request):
    if request.method == "POST":
        postData = re.split(r'\{\"(.+|\[+|\]+)\"\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"]}"
        func = json.loads(jsonData)
        funcObj = {}
        funcObj['name'] = func['name']
        funcObj['globals'] = func['global']
        funcObj['import'] = func['import']
        funcObj['declaration'] = func['declaration']
        funcObj['definition'] = func['definition']

        DAO.add_new_function(funcObj)

    return HttpResponse(200)

def add_feature(request):
    if request.method == "POST":
        print(request.body)
        postData = re.split(r'{\"(.+|\[+|\]+)\]\}', str(request.body))[1]
        jsonData = '{\"' + postData + "]}"
        print(jsonData)
        feat = json.loads(jsonData)
        type_name = feat['type']
        feat_type = Feature_Type.objects.get_or_create(name=type_name)[0]

        featObj = {}
        featObj['name'] = feat['name']
        featObj['body'] = feat['body']
        featObj['priority'] = feat['priority']
        featObj['functions'] = feat['functions']
        featObj['type'] = feat_type
        featObj['prompt'] = feat['prompt']
        featObj['options'] = feat['options']

        DAO.add_new_feature(featObj)

    return HttpResponse(200)

def get_imports(request):
    try:
        func = request.GET['name']
    except datastructures.MultiValueDictKeyError as e:
        return HttpResponse(400)

    imports = DAO.get_function_imports(func)
    parsed_i = []
    if(imports != None):
        for i in imports:
            parsed_i.append(i.text)
    return HttpResponse(json.dumps(parsed_i))

def get_function(request):
    if request.method == "DELETE":
        postData = re.split(r'b\'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        func = json.loads(jsonData)
        DAO.delete_function(func['name'])
        return HttpResponse(200)
    else:
        try:
            func = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        funcObj = DAO.get_python_function_obj(func)
        if funcObj == None:
            return HttpResponse(400)

        return HttpResponse(json.dumps(funcObj))

def get_feature(request):
    if request.method == "DELETE":
        postData = re.split(r'b\'\{\"(.+|\[+|\]+)\"\}', str(request.body))[1]
        jsonData = '{\"' + postData + "\"}"
        feat = json.loads(jsonData)
        DAO.delete_record_by_name(Feature, feat['name'])
        return HttpResponse(200)
    elif request.method == "GET":
        try:
            feat = request.GET['name']
        except datastructures.MultiValueDictKeyError as e:
            return HttpResponse(400)

        print("feat is " + feat)
        # try to find the feature, if it doesnt exist return 400
        feat = DAO.get_python_feature_obj(feat)
        if feat == None:
            return HttpResponse(400)

        return HttpResponse(json.dumps(feat))

def build(request):
    if request.method == "POST":
        postData = re.split(r'\{\"(.+|\[+|\]+)\}', str(request.body))[1]
        postData = '{"' + postData + '}'
        jsonData = json.loads(postData)
        featList = []
        if 'Execution Conditions' in jsonData:
            exeFeats = jsonData['Execution Conditions']
            for f in exeFeats:
                featList.append(f)
        if 'Executable Features' in jsonData:
            exeFeats = jsonData['Executable Features']
            for f in exeFeats:
                featList.append(f)
        if 'Action Sequence' in jsonData:
            exeFeats = jsonData['Action Sequence']
            for f in exeFeats:
                featList.append(f)
        # print(featList)

    # HARDCODED TO TRUE while developing on my Mac
    results = main(featList)
    # results = 'test.exe' # a successful build

    if results != -1:
        filename = ''
        # filename = 'http://localhost:50000/static/compiled_samples/' + results
        return HttpResponse('200 ' + filename)
    else:
        return HttpResponse(503)

def make_array(qSet):
    array = []
    if(qSet != None):
        for s in qSet:
            array.append(s.text)
    return array
